/**
 * Firestore Task Service
 * 
 * Provides CRUD operations and real-time synchronization for tasks.
 * All operations are scoped to the authenticated user's tasks.
 * 
 * Features:
 * - Create new tasks with auto-generated IDs
 * - Update tasks (partial updates supported)
 * - Delete tasks
 * - Real-time subscription to user's tasks
 * - Automatic timestamp management (createdAt, updatedAt)
 * - Strong TypeScript typing
 * - Comprehensive error handling
 */

import firestore from '@react-native-firebase/firestore';
import { Task, CreateTaskPayload, UpdateTaskPayload } from '../types';

/**
 * Firestore collection reference for tasks
 * Collection structure: /tasks/{taskId}
 */
const tasksCollection = firestore().collection('tasks');

/**
 * Add a new task to Firestore
 * 
 * Automatically adds:
 * - Document ID (auto-generated by Firestore)
 * - userId (from authenticated user)
 * - createdAt timestamp (ISO string)
 * - updatedAt timestamp (ISO string)
 * 
 * @param taskData - Task data without auto-generated fields
 * @param userId - ID of the authenticated user
 * @returns Promise resolving to the created task with ID
 * @throws Error if creation fails (network, permissions, etc.)
 * 
 * Example:
 * ```ts
 * const newTask = await addTask({
 *   title: 'Complete project',
 *   description: 'Finish all remaining features',
 *   dateTime: '2026-02-20T10:00:00.000Z',
 *   deadline: '2026-02-25T18:00:00.000Z',
 *   priority: Priority.HIGH,
 *   category: Category.WORK,
 *   completed: false,
 * }, user.uid);
 * ```
 */
export const addTask = async (
  taskData: CreateTaskPayload,
  userId: string
): Promise<Task> => {
  const now = new Date().toISOString();
  
  // Generate document ID locally (instant, no server round-trip)
  const docRef = tasksCollection.doc();
  
  // Prepare task document with auto-generated fields
  const taskDoc = {
    ...taskData,
    userId,
    createdAt: now,
    updatedAt: now,
  };
  
  // Fire-and-forget: write to Firestore without awaiting server confirmation.
  // Data is written to local cache immediately; real-time listener handles sync.
  docRef.set(taskDoc).catch((error: any) => {
    console.error('Error adding task:', error);
  });
  
  // Return complete task with locally-generated ID immediately
  return {
    id: docRef.id,
    ...taskDoc,
  } as Task;
};

/**
 * Update an existing task in Firestore
 * 
 * Supports partial updates - only provided fields are updated.
 * Automatically updates the updatedAt timestamp.
 * 
 * @param taskId - ID of the task to update
 * @param updates - Partial task data to update
 * @returns Promise that resolves when update is complete
 * @throws Error if update fails (not found, permissions, network, etc.)
 * 
 * Example:
 * ```ts
 * // Mark task as completed
 * await updateTask('abc123', { completed: true });
 * 
 * // Update title and priority
 * await updateTask('abc123', {
 *   title: 'Updated title',
 *   priority: Priority.LOW,
 * });
 * ```
 */
export const updateTask = async (
  taskId: string,
  updates: Partial<Omit<Task, 'id' | 'userId' | 'createdAt'>>
): Promise<void> => {
  const now = new Date().toISOString();
  
  // Add updatedAt timestamp to updates
  const updateData = {
    ...updates,
    updatedAt: now,
  };
  
  // Fire-and-forget: write to local cache immediately, sync in background
  tasksCollection.doc(taskId).update(updateData).catch((error: any) => {
    console.error('Error updating task:', error);
  });
};

/**
 * Delete a task from Firestore
 * 
 * @param taskId - ID of the task to delete
 * @returns Promise that resolves when deletion is complete
 * @throws Error if deletion fails (not found, permissions, network, etc.)
 * 
 * Example:
 * ```ts
 * await deleteTask('abc123');
 * ```
 */
export const deleteTask = async (taskId: string): Promise<void> => {
  // Fire-and-forget: delete from local cache immediately, sync in background
  tasksCollection.doc(taskId).delete().catch((error: any) => {
    console.error('Error deleting task:', error);
  });
};

/**
 * Subscribe to real-time updates for a user's tasks
 * 
 * Sets up a Firestore listener that triggers the callback whenever:
 * - Tasks are added
 * - Tasks are updated
 * - Tasks are deleted
 * 
 * The callback receives the complete, current list of tasks.
 * Tasks are automatically filtered by userId via Firestore query.
 * 
 * @param userId - ID of the authenticated user
 * @param onTasksUpdate - Callback function that receives updated task list
 * @param onError - Optional callback for handling errors
 * @returns Unsubscribe function to stop listening
 * 
 * Example:
 * ```ts
 * const unsubscribe = subscribeToUserTasks(
 *   user.uid,
 *   (tasks) => {
 *     console.log('Tasks updated:', tasks);
 *     setTasks(tasks);
 *   },
 *   (error) => {
 *     console.error('Subscription error:', error);
 *   }
 * );
 * 
 * // Later, when component unmounts:
 * unsubscribe();
 * ```
 */
export const subscribeToUserTasks = (
  userId: string,
  onTasksUpdate: (tasks: Task[]) => void,
  onError?: (error: Error) => void
): (() => void) => {
  // Query tasks belonging to the user
  const query = tasksCollection.where('userId', '==', userId);
  
  // Set up real-time listener
  const unsubscribe = query.onSnapshot(
    (snapshot) => {
      // Transform Firestore documents to Task objects
      const tasks: Task[] = snapshot.docs.map((doc) => {
        const data = doc.data();
        return {
          id: doc.id,
          userId: data.userId,
          title: data.title,
          description: data.description,
          dateTime: data.dateTime,
          deadline: data.deadline,
          priority: data.priority,
          category: data.category,
          completed: data.completed,
          createdAt: data.createdAt,
          updatedAt: data.updatedAt,
        } as Task;
      });
      
      // Notify callback with updated tasks
      onTasksUpdate(tasks);
    },
    (error: any) => {
      console.error('Error in task subscription:', error);
      
      // Parse error and notify error callback
      let errorMessage = 'Failed to sync tasks.';
      
      if (error.code === 'permission-denied') {
        errorMessage = 'Permission denied. Please sign in again.';
      } else if (error.code === 'unavailable') {
        errorMessage = 'Network error. Tasks will sync when connection is restored.';
      }
      
      const processedError = new Error(errorMessage);
      
      if (onError) {
        onError(processedError);
      } else {
        // If no error handler provided, just log
        console.error('Task subscription error:', processedError);
      }
    }
  );
  
  // Return unsubscribe function for cleanup
  return unsubscribe;
};

/**
 * Get all tasks for a user (one-time fetch, no real-time updates)
 * 
 * Use this for one-time data fetching.
 * For real-time updates, use subscribeToUserTasks instead.
 * 
 * @param userId - ID of the authenticated user
 * @returns Promise resolving to array of tasks
 * @throws Error if fetch fails
 */
export const getUserTasks = async (userId: string): Promise<Task[]> => {
  try {
    const query = tasksCollection.where('userId', '==', userId);
    const snapshot = await query.get();
    
    const tasks: Task[] = snapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        userId: data.userId,
        title: data.title,
        description: data.description,
        dateTime: data.dateTime,
        deadline: data.deadline,
        priority: data.priority,
        category: data.category,
        completed: data.completed,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
      } as Task;
    });
    
    return tasks;
  } catch (error: any) {
    console.error('Error fetching tasks:', error);
    
    if (error.code === 'permission-denied') {
      throw new Error('You do not have permission to access tasks.');
    } else if (error.code === 'unavailable') {
      throw new Error('Network error. Please check your connection.');
    }
    
    throw new Error('Failed to fetch tasks. Please try again.');
  }
};

/**
 * Toggle task completion status
 * 
 * Convenience function to mark task as completed/incomplete.
 * 
 * @param taskId - ID of the task to toggle
 * @param completed - New completion status
 * @returns Promise that resolves when update is complete
 */
export const toggleTaskCompletion = async (
  taskId: string,
  completed: boolean
): Promise<void> => {
  return updateTask(taskId, { completed });
};
